<!DOCTYPE html>
<html>
<head>
    <title>Personal Projects</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <header>
        <h1>Personal Projects</h1>
    </header>

    <div class="table-of-contents">
        <h2>Table of Contents</h2>
        <table>
            <tr>
                <td><a href="1. Dataset Generator: Dot or No-Dot">Dataset Generator: Dot or No-Dot</a></td>
            </tr>
            <tr>
                <td><a href="#1.1 description">1.1 Description</a></td>
            </tr>
            <tr>
                <td><a href="#1.1 code">1.2 Code</a></td>
            </tr>
            <tr>
                <td><a href="#1.3 references">1.3 References</a></td>
            </tr>
            <tr>
                <td><a href="2 Dataset Generator: Tetris Classifier">2 Dataset Generator: Tetris Classifier</a></td>
            </tr>
            <tr>
                <td><a href="#2.1 description">2.1 Description</a></td>
            </tr>
            <tr>
                <td><a href="#2.2 code">2.2 Code</a></td>
            </tr>
            <tr>
                <td><a href="#2.3 references">2.3 References</a></td>
            </tr>
        </table>
    </div>

    <section id="1. Dataset Generator: Dot or No-Dot">
        <h2>1. Dataset Generator: Dot or No-Dot</h2>
    
        <section class="subsection" id="1.1 description">
            <h3>1.1 Description</h3>
            <p>One of the great problems in the realm of Domain Generalization is generalizing the idea of numbers such that I could train a machine learning model on a data set like MNIST then use that model to accurately classify another number dataset like USPS or SHVN. Current models struggle to generalize since they are unable to capture the abstract  idea of number. When a model is trained on a number set, its description of a number is rooted in size, color, shape, and location. So when the model is tested on another dataset where the representation of a number may vary in the aforementioned qualities, the model fails. So the question is, can we develop a model to generalize.</p>
            <p>I realized early on that to find such a model it is first worth simplifying the data set so that the object being abstracted is simple. So I came up with the idea of the Dot or No-Dot data set. The code I have above generates images of specified dimension and quantity, half of which have a dot and the other half does not. The images that have no dot are a randomly selected gradient. In images with a dot, I randomly vary the background color, the background gradient, the dot color, the dot location, and the dot size. As a result, in each image the idea of a dot or no dot is represented differently, hence a model that is able to classify the images correctly has abstracted the idea of dot invariant of color, size and location.  The motivation is that such a model may also be able to abstract the idea of a number.</p>
        </section>
    
        <section class="subsection" id="1.2 code">
            <h3>1.2 Code</h3>
            <pre><code>
        import numpy as np
        import matplotlib.pyplot as plt
        from random import randint, choice
                
        def generate_mixed_dataset(num_images):
            images = []  # Store generated images
            labels = []  # Store labels for the images
                
            for _ in range(num_images // 2):
                # Create a homogeneous background image
                base_color = np.random.randint(0, 256, 3)  # Pick a random color
                homogeneous_image = np.zeros((32, 32, 3), dtype=np.uint8)
                for x in range(32):
                    for y in range(32):
                        # Add some random variation to the color
                        variation = np.random.randint(-10, 11, 3)
                        pixel_color = np.clip(base_color + variation, 0, 255)
                        homogeneous_image[x, y] = pixel_color
                images.append(homogeneous_image)
                labels.append(0)  # 0 for no dot
                
                # Create an image with a dot on a gradient background
                base_color = np.random.randint(0, 256, 3)  # Again, pick a random color
                gradient_image = np.zeros((32, 32, 3), dtype=np.uint8)
                for x in range(32):
                    for y in range(32):
                        # Make a gradient variation
                        variation = np.random.randint(-10, 11, 3)
                        pixel_color = np.clip(base_color + variation, 0, 255)
                        gradient_image[x, y] = pixel_color
                dot_size = randint(1, 4)  # Choose a random size for the dot
                x = randint(0, 32 - dot_size)  # Random position for the dot
                y = randint(0, 32 - dot_size)
                dot_color = np.random.randint(0, 256, 3)  # Random color for the dot
                # Make sure the dot color stands out
                while np.any(np.abs(dot_color - gradient_image[x, y]) < 20):
                    dot_color = np.random.randint(0, 256, 3)
                for i in range(dot_size):
                    for j in range(dot_size):
                        gradient_image[x + i, y + j] = dot_color  # Place the dot
                images.append(gradient_image)
                labels.append(1)  # 1 for dot present
                
            return images, labels
            </code></pre>
            <p>Brief overview of the coding aspects of the project or links to code repositories...</p>
        </section>
    
        <section class="subsection" id="1.3 references">
            <h3>1.3 References</h3>
            <p>List of references, resources, and acknowledgments used in the project...</p>
        </section>
    </section>
    <section id="2. Dataset Generator: Tetris Classifier">
        <h2>2. Dataset Generator: Tetris Classifier</h2>
    
        <section class="subsection" id="2.1 description">
            <h3>2.1 Description</h3>
            <p>The following code is the code I used to generate randomly, color, located, oriented tetris shapes. The following dataset represents the next step for a model built to abstract structures. Unlike the dot example, the following dataset requires that model to understand also the structure of the object, invariant to the structure's orientation. Additionally, the task also increases in difficulty now that the classifier must be non-binary. A model that is able to classify the following dataset appropriately may be robust enough for other complex structures like shapes,or  maybe even numbers. </p>
        </section>
    
        <section class="subsection" id="2.2 code">
            <h3>2.2 Code</h3>
            <pre><code>
        import numpy as np
        import matplotlib.pyplot as plt
        from random import randint, choice
                
        def generate_tetris_shape(shape_type):
            shapes = {
                "I": np.array([[1, 1, 1, 1]]),
                "O": np.array([[1, 1], [1, 1]]),
                "T": np.array([[1, 1, 1], [0, 1, 0]]),
                "S": np.array([[0, 1, 1], [1, 1, 0]]),
                "L": np.array([[0, 0, 1], [1, 1, 1]])
                    }
            return shapes[shape_type]
                
        def rotate_shape(shape):
            return np.rot90(shape, k=randint(0, 3))
                
        def generate_mixed_dataset(num_images, image_dim):
            images = []
            labels = []
                
            for _ in range(num_images // 2):
                # Homogeneous background image
                base_color = np.random.randint(0, 256, 3)
                homogeneous_image = np.zeros((image_dim, image_dim, 3), dtype=np.uint8)
                for x in range(image_dim):
                    for y in range(image_dim):
                        variation = np.random.randint(-10, 11, 3)
                        pixel_color = np.clip(base_color + variation, 0, 255)
                        homogeneous_image[x, y] = pixel_color
                images.append(homogeneous_image)
                labels.append("None")
                
                # Image with a Tetris shape
                base_color = np.random.randint(0, 256, 3)
                gradient_image = np.zeros((image_dim, image_dim, 3), dtype=np.uint8)
                for x in range(image_dim):
                    for y in range(image_dim):
                        variation = np.random.randint(-10, 11, 3)
                        pixel_color = np.clip(base_color + variation, 0, 255)
                        gradient_image[x, y] = pixel_color
                
                shape_type = choice(["I", "O", "T", "S", "L"])
                shape = generate_tetris_shape(shape_type)
                shape = rotate_shape(shape)
                
                x = randint(0, image_dim - shape.shape[0])
                y = randint(0, image_dim - shape.shape[1])
                shape_color = np.random.randint(0, 256, 3)
                for i in range(shape.shape[0]):
                    for j in range(shape.shape[1]):
                        if shape[i, j] == 1:
                            gradient_image[x + i, y + j] = shape_color
                
                images.append(gradient_image)
                labels.append(shape_type)
                
            return images, labels
        
            </code></pre>
            <p>Brief overview of the coding aspects of the project or links to code repositories...</p>
        </section>
    
        <section class="subsection" id="2.3 references">
            <h3>2.3 References</h3>
            <p>List of references, resources, and acknowledgments used in the project...</p>
        </section>
    </section>
</body>
</html>
